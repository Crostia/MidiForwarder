; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

#define MyAppName "MidiForwarder"
#define MyAppVersion "1.0.1"
#define MyAppPublisher "Crostia"
#define MyAppURL "https://github.com/Crostia/MidiForwarder"
#define MyAppExeName "MidiForwarder.exe"

[Setup]
; NOTE: The value of AppId uniquely identifies this application. Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{09121516-0522-8518-9A14-080914072008}}
AppName={#MyAppName}
; 在64位系统上使用64位安装模式，写入64位注册表
ArchitecturesInstallIn64BitMode=x64
ArchitecturesAllowed=x64
AppVersion={#MyAppVersion}
;AppVerName={#MyAppName} {#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName={autopf}\{#MyAppName}
DisableProgramGroupPage=yes
; Uncomment the following line to run in non administrative install mode (install for current user only.)
;PrivilegesRequired=lowest
OutputDir=Output
OutputBaseFilename=MidiForwarderInstaller
Compression=lzma
SolidCompression=yes
WizardStyle=modern

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"; LicenseFile: "PrivacyPolicy_en.txt"
Name: "chinesesimplified"; MessagesFile: "ChineseSimplified.isl"; LicenseFile: "PrivacyPolicy_zh.txt"

[Code]
var
  UninstallPath: string;
  UninstallFound: Boolean;

// 检查程序是否正在运行
function IsAppRunning(const AppName: string): Boolean;
var
  WMI: Variant;
  WbemLocator: Variant;
  WbemServices: Variant;
  WQL: string;
  QueryResult: Variant;
  Item: Variant;
  I: Integer;
begin
  Result := False;
  try
    WMI := CreateOleObject('WbemScripting.SWbemLocator');
    WbemServices := WMI.ConnectServer('localhost', 'root\cimv2');
    WQL := 'SELECT Name FROM Win32_Process WHERE Name="' + AppName + '"';
    QueryResult := WbemServices.ExecQuery(WQL);
    if not VarIsNull(QueryResult) then
    begin
      for I := 0 to QueryResult.Count - 1 do
      begin
        Item := QueryResult.ItemIndex(I);
        if not VarIsNull(Item) then
        begin
          Result := True;
          Break;
        end;
      end;
    end;
  except
    // 如果WMI查询失败，尝试使用FindWindow方法
    Result := (FindWindowByWindowName('{#MyAppName}') <> 0);
  end;
end;

// 获取已安装程序的卸载路径
function GetUninstallString(): string;
var
  UninstallKey: string;
  TempResult: string;
begin
  Result := '';
  // 使用与 AppId 对应的 GUID
  // AppId: {{09121516-0522-8518-9A14-080914072008}}
  // 注册表键名: {09121516-0522-8518-9A14-080914072008}}_is1 (注意双大括号)
  UninstallKey := 'Software\Microsoft\Windows\CurrentVersion\Uninstall\{09121516-0522-8518-9A14-080914072008}}_is1';
  
  // 检查 HKLM 64-bit（所有用户安装）- 现在使用64位注册表
  if RegQueryStringValue(HKLM64, UninstallKey, 'UninstallString', TempResult) then
  begin
    Result := TempResult;
    Exit;
  end;
    
  // 检查 HKLM 32-bit（所有用户安装，32位程序）- 兼容旧版本
  if RegQueryStringValue(HKLM32, UninstallKey, 'UninstallString', TempResult) then
  begin
    Result := TempResult;
    Exit;
  end;
    
  // 检查 HKCU 64-bit（当前用户安装）
  if RegQueryStringValue(HKCU64, UninstallKey, 'UninstallString', TempResult) then
  begin
    Result := TempResult;
    Exit;
  end;
    
  // 检查 HKCU 32-bit（当前用户安装，32位程序）
  if RegQueryStringValue(HKCU32, UninstallKey, 'UninstallString', TempResult) then
  begin
    Result := TempResult;
    Exit;
  end;
    
  Result := '';
end;

// 获取当前语言代码
function GetLanguageCode(): string;
begin
  Result := ExpandConstant('{language}');
end;

// 初始化安装程序
function InitializeSetup(): Boolean;
var
  V: Integer;
  ErrorCode: Integer;
  UninstallString: string;
  MsgRunning: string;
  MsgUninstall: string;
  MsgUninstallConfirm: string;
  MsgUninstallFailed: string;
  LangCode: string;
begin
  Result := True;
  
  // 获取当前语言代码
  LangCode := GetLanguageCode();
  
  // 根据语言设置消息文本 (使用 #13#10 作为换行符)
  if LangCode = 'chinesesimplified' then
  begin
    MsgRunning := '安装程序检测到 {#MyAppName} 正在运行。' + #13#10 + #13#10 + '请先关闭所有实例，然后点击"确定"继续，或点击"取消"退出。';
    MsgUninstall := '检测到 {#MyAppName} 已安装。' + #13#10 + #13#10 + '是否先卸载旧版本？';
    MsgUninstallConfirm := '卸载程序检测到 {#MyAppName} 正在运行。' + #13#10 + #13#10 + '请先关闭所有实例，然后点击"确定"继续，或点击"取消"退出。';
    MsgUninstallFailed := '卸载失败。是否继续安装？';
  end
  else
  begin
    MsgRunning := 'Setup has detected that {#MyAppName} is currently running.' + #13#10 + #13#10 + 'Please close all instances and click "OK" to continue, or "Cancel" to exit.';
    MsgUninstall := '{#MyAppName} is already installed.' + #13#10 + #13#10 + 'Do you want to uninstall the old version first?';
    MsgUninstallConfirm := 'The uninstaller has detected that {#MyAppName} is currently running.' + #13#10 + #13#10 + 'Please close all instances and click "OK" to continue, or "Cancel" to exit.';
    MsgUninstallFailed := 'Uninstallation failed. Do you want to continue with installation?';
  end;
  
  // 检查程序是否正在运行
  while IsAppRunning('{#MyAppExeName}') do
  begin
    V := MsgBox(MsgRunning, mbError, MB_OKCANCEL);
    if V = IDCANCEL then
    begin
      Result := False;
      Exit;
    end;
  end;
  
  // 检查是否已安装
  UninstallString := GetUninstallString();
  if UninstallString <> '' then
  begin
    if MsgBox(MsgUninstall, mbConfirmation, MB_YESNO) = IDYES then
    begin
      // 检查卸载时程序是否运行
      while IsAppRunning('{#MyAppExeName}') do
      begin
        V := MsgBox(MsgUninstallConfirm, mbError, MB_OKCANCEL);
        if V = IDCANCEL then
        begin
          Result := False;
          Exit;
        end;
      end;
      
      // 执行卸载
      UninstallFound := True;
      UninstallPath := RemoveQuotes(UninstallString);
      if not ShellExec('', UninstallPath, '/SILENT', '', SW_SHOWNORMAL, ewWaitUntilTerminated, ErrorCode) then
      begin
        if MsgBox(MsgUninstallFailed, mbError, MB_YESNO) = IDNO then
        begin
          Result := False;
          Exit;
        end;
      end;
      
      // 等待卸载完成并确保文件系统释放
      Sleep(1000);  // 延时1秒
    end;
  end;
end;

// 获取配置文件路径
function GetConfigFilePath(): string;
begin
  Result := ExpandConstant('{userappdata}\MidiForwarder\config.json');
end;

// 读取配置文件内容
function ReadConfigFile(): string;
var
  ConfigPath: string;
  FileContent: AnsiString;
begin
  Result := '';
  ConfigPath := GetConfigFilePath();
  if FileExists(ConfigPath) then
  begin
    if LoadStringFromFile(ConfigPath, FileContent) then
      Result := FileContent;
  end;
end;

// 写入配置文件
procedure WriteConfigFile(const Content: string);
var
  ConfigPath: string;
  ConfigDir: string;
  FileContent: AnsiString;
begin
  ConfigPath := GetConfigFilePath();
  ConfigDir := ExtractFileDir(ConfigPath);
  
  // 确保目录存在
  if not DirExists(ConfigDir) then
  begin
    if not CreateDir(ConfigDir) then
      Exit;
  end;
  
  FileContent := Content;
  SaveStringToFile(ConfigPath, FileContent, False);
end;

// 更新配置文件中的字符串字段值
procedure UpdateConfigStringValue(var ConfigContent: string; const FieldName: string; const FieldValue: string; IsStringValue: Boolean);
var
  FieldPos: Integer;
  ColonPos: Integer;
  ValueStart: Integer;
  ValueEnd: Integer;
  FieldPattern: string;
  NewValue: string;
  RestOfString: string;
begin
  FieldPattern := '"' + FieldName + '"';
  
  if IsStringValue then
    NewValue := '"' + FieldValue + '"'
  else
    NewValue := FieldValue;
  
  FieldPos := Pos(FieldPattern, ConfigContent);
  if FieldPos > 0 then
  begin
    // 找到冒号位置（在字段名之后）
    ColonPos := 0;
    ValueStart := FieldPos + Length(FieldPattern);
    while ValueStart <= Length(ConfigContent) do
    begin
      if ConfigContent[ValueStart] = ':' then
      begin
        ColonPos := ValueStart;
        Break;
      end;
      ValueStart := ValueStart + 1;
    end;
    
    if ColonPos > 0 then
    begin
      // 找到值开始位置（跳过空格）
      ValueStart := ColonPos + 1;
      while (ValueStart <= Length(ConfigContent)) and (ConfigContent[ValueStart] = ' ') do
        ValueStart := ValueStart + 1;
      
      // 找到值结束位置
      ValueEnd := ValueStart;
      if ConfigContent[ValueStart] = '"' then
      begin
        // 字符串值，找到结束引号
        ValueEnd := ValueEnd + 1;
        while (ValueEnd <= Length(ConfigContent)) and (ConfigContent[ValueEnd] <> '"') do
          ValueEnd := ValueEnd + 1;
        ValueEnd := ValueEnd + 1;
      end
      else
      begin
        // 非字符串值
        while (ValueEnd <= Length(ConfigContent)) and 
              not ((ConfigContent[ValueEnd] = ',') or (ConfigContent[ValueEnd] = '}') or (ConfigContent[ValueEnd] = #13) or (ConfigContent[ValueEnd] = #10)) do
          ValueEnd := ValueEnd + 1;
      end;
      
      // 替换值
      ConfigContent := Copy(ConfigContent, 1, ValueStart - 1) + 
                       NewValue + 
                       Copy(ConfigContent, ValueEnd, Length(ConfigContent) - ValueEnd + 1);
    end;
  end
  else
  begin
    // 如果字段不存在，在 { 之后添加（作为第一个字段）
    FieldPos := Pos('{', ConfigContent);
    if FieldPos > 0 then
    begin
      Insert('  "' + FieldName + '": ' + NewValue + ',' + #13#10, ConfigContent, FieldPos + 1);
    end;
  end;
end;

// 更新配置文件中的 AutoStart 设置
procedure UpdateConfigAutoStart(AutoStart: Boolean);
var
  ConfigContent: string;
  AutoStartStr: string;
begin
  ConfigContent := ReadConfigFile();
  
  if AutoStart then
    AutoStartStr := 'true'
  else
    AutoStartStr := 'false';
  
  if ConfigContent = '' then
  begin
    // 配置文件不存在，创建新的配置
    ConfigContent := '{' + #13#10 +
                     '  "SelectedInputDeviceId": -1,' + #13#10 +
                     '  "SelectedOutputDeviceId": -1,' + #13#10 +
                     '  "AutoStart": ' + AutoStartStr + ',' + #13#10 +
                     '  "StartMinimized": false,' + #13#10 +
                     '  "AutoConnectOnStartup": false,' + #13#10 +
                     '  "MinimizeToTray": true,' + #13#10 +
                     '  "HasShownTrayPrompt": false,' + #13#10 +
                     '  "Language": ""' + #13#10 +
                     '}';
  end
  else
  begin
    // 更新现有的 AutoStart 配置
    UpdateConfigStringValue(ConfigContent, 'AutoStart', AutoStartStr, False);
  end;
  
  WriteConfigFile(ConfigContent);
end;

// 更新配置文件中的 Language 设置
procedure UpdateConfigLanguage(const LangCode: string);
var
  ConfigContent: string;
  LangValue: string;
begin
  ConfigContent := ReadConfigFile();
  
  // 将语言代码转换为应用程序使用的格式
  if LangCode = 'chinesesimplified' then
    LangValue := 'zh'
  else if LangCode = 'english' then
    LangValue := 'en'
  else
    LangValue := ''; // 默认使用系统语言
  
  if ConfigContent = '' then
  begin
    // 配置文件不存在，创建新的配置
    ConfigContent := '{' + #13#10 +
                     '  "SelectedInputDeviceId": -1,' + #13#10 +
                     '  "SelectedOutputDeviceId": -1,' + #13#10 +
                     '  "AutoStart": false,' + #13#10 +
                     '  "StartMinimized": false,' + #13#10 +
                     '  "AutoConnectOnStartup": false,' + #13#10 +
                     '  "MinimizeToTray": true,' + #13#10 +
                     '  "HasShownTrayPrompt": false,' + #13#10 +
                     '  "Language": "' + LangValue + '"' + #13#10 +
                     '}';
  end
  else
  begin
    // 更新现有的 Language 配置
    UpdateConfigStringValue(ConfigContent, 'Language', LangValue, True);
  end;
  
  WriteConfigFile(ConfigContent);
end;

procedure InitializeWizard;
begin
  // 初始化完成
end;

// 安装完成后步骤
procedure CurStepChanged(CurStep: TSetupStep);
var
  LangCode: string;
begin
  if CurStep = ssPostInstall then
  begin
    // 获取安装时选择的语言
    LangCode := GetLanguageCode();
    
    // 写入语言配置
    UpdateConfigLanguage(LangCode);
    
    // 安装完成后，根据用户选择更新配置文件
    if WizardIsTaskSelected('startup') then
      UpdateConfigAutoStart(True)
    else
      UpdateConfigAutoStart(False);
  end;
end;

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked
Name: "startup"; Description: "{cm:AutoStartProgram,{#StringChange(MyAppName, '&', '&&')}}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked

[Files]
Source: "bin\Release\net8.0-windows\win-x64\publish\{#MyAppExeName}"; DestDir: "{app}"; Flags: ignoreversion
Source: "bin\Release\net8.0-windows\win-x64\publish\*.dll"; DestDir: "{app}"; Flags: ignoreversion
; NOTE: Don't use "Flags: ignoreversion" on any shared system files

[Icons]
Name: "{autoprograms}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"
Name: "{autodesktop}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: desktopicon
[Registry]
; 开机自启注册表项
Root: HKLM; Subkey: "SOFTWARE\Microsoft\Windows\CurrentVersion\Run"; ValueType: string; ValueName: "{#MyAppName}"; ValueData: """{app}\{#MyAppExeName}"""; Flags: uninsdeletevalue; Tasks: startup

[CustomMessages]
; 英文自定义消息
english.AutoStartProgramGroupDescription=Startup Options
english.AutoStartProgram=Start {#MyAppName} automatically when Windows starts
english.AdditionalIcons=Additional options:
english.CreateDesktopIcon=Create a &desktop shortcut
english.CreateQuickLaunchIcon=Create a &Quick Launch shortcut
english.LaunchProgram=Launch {#MyAppName}

; 中文自定义消息
chinesesimplified.AutoStartProgramGroupDescription=启动选项
chinesesimplified.AutoStartProgram=开机时自动启动 {#MyAppName}
chinesesimplified.AdditionalIcons=附加选项：
chinesesimplified.CreateDesktopIcon=创建桌面快捷方式(&D)
chinesesimplified.CreateQuickLaunchIcon=创建快速启动快捷方式(&Q)
chinesesimplified.LaunchProgram=启动 {#MyAppName}

[Run]
Filename: "{app}\{#MyAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: nowait postinstall skipifsilent

[UninstallDelete]
; 卸载时删除配置文件、配置目录、注册表项和安装目录
Type: filesandordirs; Name: "{userappdata}\MidiForwarder"
Type: dirifempty; Name: "{app}"